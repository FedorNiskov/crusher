### Общее описание

Этот пример демонстрирует применение символьного выполнения 
при фаззинге встроенного сетевого модуля UEFI.
Это осуществляется на основе частичной эмуляции с помощью Dual-Emu.

### Описание целевого кода

Целевой код находится в модуле `Ip4Dxe.efi`
(встроенный сетевой модуль OVMF-UEFI,
ответственный за обработку пакетов про протоколу IP v4).
Целевая функция - `Ip4PreProcessPacket` - 
занимается первичной обработкой входящего IP-пакета.
Исходный код - `NetworkPkg/Ip4Dxe/Ip4Input.c`
(https://github.com/tianocore/edk2).
Начальная точка - вход в эту функцию,
конечная точка - возврат из неё.

### Сборка

Для сборки следует использовать Docker-контейнер с Ubuntu 22.04:

```
docker run -it --privileged ubuntu:22.04 /bin/bash
```

С помощью команды `docker cp` следует поместить папку `building` в корень контейнера,
затем внутри перейти в неё, запустить `./build.sh`
и забрать на хост полученный файл образа `ovmf.fd`.

Собранный образ можно запустить в Qemu командой:

```
qemu-system-x86_64 -bios ./ovmf.fd -serial mon:stdio -nographic -s
```

Для снятия снимка нужно подключиться к Qemu в GDB,
поставить точку останова на целевую функцию,
дойти до неё, считать регистры и сохранить память.
Т.е. используются следующие команды GDB:

```
target remote :1234
break * 0x06895DDE
continue

info registers
dump memory mem.bin 0x00000000 0x08000000
```

Чтобы дойти до точки, можно, например, выполнить следующие действия:
дождаться появления консоли UEFI;
настроить сеть (`ifconfig -s eth0 dhcp`);
выполнить сетевую операцию (`ping 10.0.2.2`).

### Общая схема эмуляции и фаззинга

Здесь основой фаззинга является частичная эмуляция -
выполнение интересующего фрагмента кода из начального состояния
на основе скрипта пользователя.
Снимок начального состояния (регистры и память) сохранён в папке `dump`.
Этот снимок получен с помощью эмулятора Qemu.
Пользовательский скрипт `script.py` использует API Dual-Emu,
чтобы указать снимок, конечную точку, входные данные и запустить эмуляцию.
Пользователь может отдельно запустить эмуляцию - конкретное или символьное выполнение -
на некотором образце входных данных.
Символьное выполнение (DSE - Dynamic Symbolic Execution)
позволяет автоматически генерировать новые образцы данных.
Также пользователь может запустить фаззинг с DSE -
символьное выполнение поможет фаззеру расширять покрытие кода.

### Запуск

Для запуска примера не требуется компиляция ПО и получение снимка -
в файлах примера уже присутствует готовый к запуску снимок и всё необходимое.

Продемонстрируем действие символьного выполнения.
Запустим его на входных данных `input_bad_cs` -
IP-пакет с неправильной контрольной суммой.
В ходе запуска генерируются новые образцы данных,
которые позволяют изменить путь в коде.
Среди этих образцов будет пакет с нулевой суммой,
а также, что примечательно, с правильной цифрой в поле версии (4).
Т.е. в этой точке ветвления (проверка суммы)
сгенерирован пакет, который позволяет пройти в другую ветвь
(данное ПО допускает пакеты с нулевой суммой),
при этом учитывается предикат пути -
должна быть указана правильная версия, чтобы дойти до этой точки.
Команда запуска (новые данные будут в папке `out`):

```
/path/to/python3 ./script.py --angr -i ./input_bad_cs -o ./out
```

Запуск конкретного выполнения:
```
/path/to/python3 ./script.py --qiling -i ./input
```

Запуск фаззинга с DSE:

```
rm -rf out; /path/to/crusher/bin_x86-64/fuzz_manager --start 4 --eat-cores 1 --dse-cores 1 -i ./in -o ./out -I dualemu -T dualemu -t 5000 -- ./script.py
```

