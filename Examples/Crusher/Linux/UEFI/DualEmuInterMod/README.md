### Общее описание

Этот пример демонстрирует фаззинг кода UEFI,
где происходит взаимодействие между встроенными модулями.
Это осуществляется на основе частичной эмуляции с помощью Dual-Emu.

### Описание целевого кода

Целевой код - это фрагмент из модуля консоли UEFI,
который взаимодействует с модулем клавиатуры.
Исходный код - функция `ShellPromptForResponse`
в файле `ShellPkg/Library/UefiShellLib/UefiShellLib.c`
(https://github.com/tianocore/edk2).
Функция ожидает события клавиатуры (нажатие клавиши),
а затем обрабатывает их.
Начальная точка - вход в эту функцию,
конечная точка - возврат из неё.
Входные данные подаются целевому коду
через функцию `ReadKeyStroke` (API модуля клавиатуры).

### Сборка

Для сборки следует использовать Docker-контейнер с Ubuntu 22.04:

```
docker run -it --privileged ubuntu:22.04 /bin/bash
```

С помощью команды `docker cp` следует поместить папку `building` в корень контейнера,
затем внутри перейти в неё, запустить `./build.sh`
и забрать на хост полученный файл образа `ovmf.fd`.
В код для удобства добавляется дополнительная отладочная печать.

Собранный образ можно запустить в Qemu командой:

```
qemu-system-x86_64 -bios ./ovmf.fd -serial mon:stdio -nographic -s
```

Для снятия снимка нужно подключиться к Qemu в GDB,
поставить точку останова на целевую функцию,
дойти до неё, считать регистры и сохранить память.
Т.е. используются следующие команды GDB:

```
target remote :1234
break * 0x62D7A03
continue

info registers
dump memory mem.bin 0x00000000 0x08000000
```

Чтобы дойти до точки, можно, например,
дождаться появления консоли UEFI
и ввести команду `mm 0`.

### Общая схема эмуляции и фаззинга

Здесь основой фаззинга является частичная эмуляция -
выполнение интересующего фрагмента кода из начального состояния
на основе скрипта пользователя.
Снимок начального состояния (регистры и память) сохранён в папке `dump`.
Этот снимок получен с помощью эмулятора Qemu.
Пользовательский скрипт `script.py` использует API Dual-Emu,
чтобы указать снимок, конечную точку, входные данные и запустить эмуляцию.
В данном примере целевая функция эмулируется с параметром `ShellPromptResponseTypeYesNoAllCancel`;
при эмуляции подменяются функции ввода-вывода, в том числе `ReadKeyStroke`,
чтобы ввести один символ и завершить ввод.
Пользователь может отдельно запустить эмуляцию (конкретное или символьное выполнение)
на некотором образце входных данных,
а также может запустить фаззинг с DSE.

### Запуск

Для запуска примера не требуется компиляция ПО и получение снимка -
в файлах примера уже присутствует готовый к запуску снимок и всё необходимое.

Запуск конкретного выполнения:

```
/path/to/python3 ./script.py --qiling -i ./input
```

Запуск символьного выполнения:

```
/path/to/python3 ./script.py --angr -i ./input -o ./out
```

Запуск фаззинга:

```
rm -rf out; /path/to/crusher/bin_x86-64/fuzz_manager --start 4 --eat-cores 1 --dse-cores 1 -i ./in -o ./out -I dualemu -T dualemu -t 5000 -- ./script.py
```


