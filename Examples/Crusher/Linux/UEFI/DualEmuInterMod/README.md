### Общее описание

Этот пример демонстрирует фаззинг кода UEFI,
где происходит взаимодействие между встроенными модулями.
Это осуществляется на основе частичной эмуляции с помощью Dual-Emu.

### Описание целевого кода

Целевой код - это фрагмент из модуля консоли UEFI,
который взаимодействует с модулем клавиатуры.
Исходный код - функция `ShellPromptForResponse`
в файле `ShellPkg/Library/UefiShellLib/UefiShellLib.c`
(https://github.com/tianocore/edk2).
Функция ожидает события клавиатуры (нажатие клавиши),
а затем обрабатывает их.
Начальная точка - вход в эту функцию,
конечная точка - возврат из неё.
Входные данные подаются целевому коду
через функцию `ReadKeyStroke` (API модуля клавиатуры).

### Сборка

Рекомендуется выполнять сборку и запуск на машине с Ubuntu 22.04.
После установки зависимостей и подготовки репозитория
(https://github.com/tianocore/edk2.git, версия `edk2-stable202311`)
нужно ввести команды сборки UEFI
и запуска в эмуляторе:
```
$ EmulatorPkg/build.sh
$ EmulatorPkg/build.sh run
```

Перед сборкой можно для удобства добавить в код печать адресов
интересующих функций (например, см. `patch.txt`).

После запуска нужно поставить точку останова на целевую функцию,
достичь её и сделать снимок состояния (регистры и память).
Т.е. вводятся следующие команды в консоль GDB:
```
run
...
<Ctrl+C>
break * &ShellPromptForResponse
continue
...
info registers
info proc mappings
// нужна память по адресам 0x4???????
dump memory mem.40000000 0x40000000 0x40020000
...
```

Чтобы достигнуть начальную точку, можно, например,
дождаться появления консоли UEFI
и ввести команду `mm 0x40000000`.

### Общая схема эмуляции и фаззинга

Здесь основой фаззинга является частичная эмуляция -
выполнение интересующего фрагмента кода из начального состояния
на основе скрипта пользователя.
Снимок начального состояния (регистры и память) сохранён в папке `dump`.
Этот снимок получен с помощью эмулятора.
Пользовательский скрипт `script.py` использует API Dual-Emu,
чтобы указать снимок, конечную точку, входные данные и запустить эмуляцию.
В данном примере целевая функция эмулируется с параметром `ShellPromptResponseTypeYesNoAllCancel`;
при эмуляции подменяются функции ввода-вывода, в том числе `ReadKeyStroke`,
чтобы ввести один символ и завершить ввод.
Пользователь может отдельно запустить эмуляцию (конкретное или символьное выполнение)
на некотором образце входных данных,
а также может запустить фаззинг с DSE.

### Запуск

Для запуска примера не требуется компиляция ПО и получение снимка -
в файлах примера уже присутствует готовый к запуску снимок и всё необходимое.

Рекомендации по подготовке Dual-Emu к запуску
можно посмотреть [здесь](../Common/README.md).

Запуск конкретного выполнения:

```
/path/to/python3 ./script.py --qiling -i ./input
```

Запуск символьного выполнения:

```
/path/to/python3 ./script.py --angr -i ./input -o ./out
```

Запуск фаззинга:

```
rm -rf out; /path/to/crusher/bin_x86-64/fuzz_manager --start 4 --eat-cores 1 --dse-cores 1 -i ./in -o ./out -I dualemu -T dualemu -t 5000 -- ./script.py
```


