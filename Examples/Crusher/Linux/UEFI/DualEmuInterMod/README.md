### Общее описание

Этот пример демонстрирует фаззинг кода UEFI,
где происходит взаимодействие между встроенными модулями.
Это осуществляется на основе частичной эмуляции с помощью Dual-Emu.

### Описание целевого кода

Целевой код - это фрагмент из модуля консоли UEFI,
который взаимодействует с модулем клавиатуры.
Исходный код - функция `ShellPromptForResponse`
в файле `ShellPkg/Library/UefiShellLib/UefiShellLib.c`
(https://github.com/tianocore/edk2).
Функция ожидает события клавиатуры (нажатие клавиши),
а затем обрабатывает их.
Начальная точка - вход в эту функцию,
конечная точка - возврат из неё.
Входные данные подаются целевому коду
через функцию `ReadKeyStroke` (API модуля клавиатуры).

### Сборка

Рекомендуется выполнять сборку и запуск на машине с Ubuntu 22.04.
После установки зависимостей и подготовки репозитория
(https://github.com/tianocore/edk2.git, версия `edk2-stable202311`)
нужно ввести команды сборки UEFI
и запуска в эмуляторе:
```
$ EmulatorPkg/build.sh
$ EmulatorPkg/build.sh run
```

Перед сборкой можно для удобства добавить в код печать адресов
интересующих функций (например, см. `patch.txt`).

После запуска нужно поставить точку останова на целевую функцию,
достичь её и сделать снимок состояния (регистры и память).
Т.е. вводятся следующие команды в консоль GDB:
```
run
...
<Ctrl+C>
break * &ShellPromptForResponse
continue
...
info registers
info proc mappings
// нужна память по адресам 0x4???????
dump memory mem.40000000 0x40000000 0x40020000
...
```

Чтобы достигнуть начальную точку, можно, например,
дождаться появления консоли UEFI
и ввести команду `mm 0x40000000`.

### Общая схема эмуляции и фаззинга

Здесь основой фаззинга является частичная эмуляция -
выполнение интересующего фрагмента кода из начального состояния
на основе скрипта пользователя.
Снимок начального состояния (регистры и память) сохранён в папке `dump`.
Этот снимок получен с помощью эмулятора.
Пользовательский скрипт `script.py` использует API Dual-Emu,
чтобы указать снимок, конечную точку, входные данные и запустить эмуляцию.
В данном примере целевая функция эмулируется с параметром `ShellPromptResponseTypeYesNoAllCancel`;
при эмуляции подменяются функции ввода-вывода, в том числе `ReadKeyStroke`,
чтобы ввести один символ и завершить ввод.
Пользователь может отдельно запустить эмуляцию (конкретное или символьное выполнение)
на некотором образце входных данных,
а также может запустить фаззинг с DSE.

### Запуск

Для запуска примера не требуется компиляция ПО и получение снимка -
в файлах примера уже присутствует готовый к запуску снимок и всё необходимое.

Рекомендации по подготовке Dual-Emu к запуску
можно посмотреть [здесь](../Common/README.md).

Запуск конкретного выполнения:

```
/path/to/python3 ./script.py --qiling -i ./input
```

Запуск символьного выполнения:

```
/path/to/python3 ./script.py --angr -i ./input -o ./out
```

Запуск фаззинга:

```
rm -rf out; /path/to/crusher/bin_x86-64/fuzz_manager --start 4 --eat-cores 1 --dse-cores 1 -i ./in -o ./out -I dualemu -T dualemu -t 5000 -- ./script.py
```

### Просмотр покрытия кода

Покрытие кода, достигнутое в результате фаззинга, можно посмотреть наглядно.
Инструмент генерирует отчёты о покрытии в формате Lighthouse,
которые можно посмотреть, например, в дизассемблере Ghidra.

Сначала нужно скачать необходимые файлы:
* Дизассемблер Ghidra (версия 11.0.2): https://github.com/NationalSecurityAgency/ghidra/releases/download/Ghidra_11.0.2_build/ghidra_11.0.2_PUBLIC_20240326.zip
* Соответствующий плагин для отображения покрытия: https://github.com/nccgroup/Cartographer/releases/download/v1.0.1/ghidra_11.0.2_Cartographer.zip

Для запуска нужна подходящая версия Java:
```
sudo apt install openjdk-17-jdk openjdk-17-jre
```

Чтобы запустить Ghidra, нужно распаковать архив и запустить `./ghidraRun`.
Чтобы установить плагин, нужно в стартовом окне использовать `File > Install Extensions`
и подать скачанный zip-файл плагина.

Нужно создать проект и импортировать исследуемый бинарный файл (`Shell.debug`).

После работы фаззера отчёты о покрытии находятся в папке `out`:
например, файл `out/EAT_OUT/results/queue/000000/lighthouse`
описывает покрытие при запуске на образце входных данных номер `000000`.
Можно собрать все эти файлы покрытия в одну папку (например, `dir_cov`)
и запустить скрипт для слияния этих файлов в один отчёт:

```
./crusher/bin_x86-64/python-2.7/bin/python ./LighthouseSum.pyc --input ./dir_cov --out ./file.cov --system Linux --select-region 0x48cf5000-0x48d65000 --rename-module Shell.debug --enum-module-table
```

В команде указан диапазон адресов, где в памяти расположен код целевого UEFI-модуля ("Shell").
После этого полученный файл `file.cov` можно загрузить в Ghidra
(в окне дизассемблера: `Tools > Code Coverage > Load Code Coverage File(s)...`).
В результате покрытые фрагменты кода будут раскрашены цветом.


